---
title: "Cicada Data"
subtitle: "Data analysis reproduction concerning the cicada's genome."
author: "Eric Mossotti"
date: today
date-modified: last-modified

bibliography: references.bib
repo: https://github.com/ericMossotti/genomics
source: genomics.qmd
abstract-title: "Objective"
abstract: "To reproduce the summary table on the cicada species summary statistics table."
description-meta: "Reproducible genomics analysis."
license: CC BY-SA
funding: "The author(s) received no specific funding for this work."

csl: csl/apa.csl
citation-location: margin
citations-hover: true
link-citations: true

toc-expand: true
toc: true
number-sections: true
link-external-newwindow: true
smooth-scroll: true
fig-responsive: true
echo: true
callout-appearance: simple

code-fold: true
---

```{r, include = FALSE}
#knitr::opts_chunk$set(engine.opts = list(bash = "-l"))
```

# Introduction

## Problem

Lack of documentation in bioinformatics research reporting. The steps involved to reproduce genomics data can be unclear.

## Purpose

To trail blaze a new trend in research with regards to reproducibility. To address the well documented and ongoing reproducibility crisis, I seek to reproduce and supplement, in this case, bioinformatics research, independently.

## Stakeholders

I consider this work of particular interest to bioinformatics researchers. More generally, the spirit of this work could translate to other domains of data intensive research and analytics.

## Source

This particular report aims to verify a table related to a species of cicada is correct by programmatically reproducing it with publicly available bioinformatics tools. [@magicica]

# Import

```{r}
reticulate::source_python("Scripts/00_Import/Python/importer/importer.py")
```

```{python}
#| label: importScript
#| code-summary: For importing files.
#| file: "Scripts/00_Import/Python/importer/importer.py"
#| eval: false 

```

```{python}
#| label: importChunk

import os
import sys
import wget

# Define the directory name
directory = "data"

# Set the url
url = "https://dnazoo.s3.wasabisys.com/Magicicada_septendecula/magicicada_hifiasm.asm.bp.p_ctg_HiC.fasta.gz"

# Set the local file path
fpath = "data/magicicada.fasta.gz"

# Map the url to the file path
fileMap = {url: fpath}

importer(directory, fileMap)
```

Contigs are crucial in accurately reconstructing the DNA sequence in a specific region. Scaffolds extend this by aligning contigs in a probable order, bridging the gaps with estimated sequences or placeholders.

# Process

## Decompress

```{bash}

# A script to decompress the fasta file in order to run assembly_stats python function on it later.

# In a quarto IDE project, run by removing '.' from '{.bash}' 
# Bash chunks fail to run with this setup, so still figuring that out
# Run chunk in IDE, then add '.' to '{bash}' before render

# The decompressed fasta file variable
fasta="data/magicicada.fasta"
# The compressed fasta.gz file variable
gzFasta="data/magicicada.fasta.gz"

# Check if gzFasta is already decompressed and written to the location
if [ ! -f $fasta ]; then
    # File doesn't exist, then decompress
    gunzip -c "$gzFasta" > "$fasta"
    echo "$fasta has been decompressed and written." 
else
    echo "The file $fasta already exists. Skipping unzip."
fi

```

# EDA

```{python}
#| label: assmblyStats

import os
import subprocess

# The uncompressed fasta file variable
fasta = "data/magicicada.fasta"
# The text file path variable generated by the script
summary_stats = "data/01_EDA/summaryStats.txt"
# The file path to the bash script
script_file = "Scripts/01_EDA/Bash/assembly_stats.sh"

# Check if the summaryStats file exists
if not os.path.isfile(summary_stats):
    # File doesn't exist, execute the Bash command
    try:
        # Run the bash script and capture its output
        output = subprocess.check_output(["bash", script_file, fasta],
        universal_newlines = True)
        
        # Write the output to the summary_stats file
        with open(summary_stats, 'w') as f:
            f.write(output)
        
        # Print the contents of the file
        print(output)
        
    except subprocess.CalledProcessError as e:
        print(f"An error occurred while running the script: {e}")
else:
    print(f"The file {summary_stats} already exists. Skipping execution.\n"
    )
    with open(summary_stats, 'r') as f:
        contents = f.read()
        print("File contents:\n", contents)
    
```

## Tables

|                        |                       |                     |                         |
|------------------------|-----------------------|---------------------|-------------------------|
| **Contig length (bp)** | **Number of contigs** | **Contig N50 (bp)** | **Longest contig (bp)** |
|                        |                       |                     |                         |

|                          |                         |                       |                           |
|--------------------------|-------------------------|-----------------------|---------------------------|
| **Scaffold length (bp)** | **Number of scaffolds** | **Scaffold N50 (bp)** | **Longest scaffold (bp)** |
|                          |                         |                       |                           |

**The** **contig N50** is a statistical measure that represents the length of the longest contig (contiguous assembled sequence) for which the sum of the lengths of all contigs of equal or greater length is at least 50% of the total genome length. In other words, it is the length of the contig at which 50% of the genome assembly is contained in contigs of that length or longer. A higher contig N50 value indicates that the assembly contains fewer and longer contigs, which is generally desirable as it suggests a more contiguous and complete assembly. A lower contig N50 value indicates that the assembly is more fragmented, with shorter contigs.

**The** **scaffold N50** is similar to the contig N50, but it considers scaffolds instead of contigs. Scaffolds are ordered and oriented contigs with gaps (represented by N's) in between them. Likewise, the scaffold N50 is the length of the longest scaffold for which the sum of the lengths of all scaffolds of equal or greater length is at least 50% of the total genome length. A higher scaffold N50 value suggests that the assembly is more contiguous, with fewer and longer scaffolds. This indicates that more contigs have been correctly ordered and oriented into scaffolds, bridging the gaps between them.

**Both contig N50 and scaffold N50** are widely used to evaluate the quality and completeness of genome assemblies, especially when comparing different assembly strategies or tools.

[De novo assembly of the Aedes aegypti genome using Hi-C yields chromosome-length scaffolds \| Science](https://www.science.org/doi/10.1126/science.aal3327)

```{mermaid}

```
