---
title: "Cicada Data"
subtitle: "Data analysis reproduction concerning the cicada's genome."
author: "Eric Mossotti"
date: today
date-modified: last-modified

bibliography: references.bib
repo: https://github.com/ericMossotti/genomics
source: genomics.qmd
abstract-title: "Objective"
abstract: "To reproduce DNA Zoo's summary table on the 17-year cicada."
description-meta: "Reproducible genomics analysis."
license: CC BY-SA
funding: "The author(s) received no specific funding for this work."

csl: csl/apa.csl
citation-location: margin
citations-hover: true
link-citations: true
citeproc: true

toc-expand: true
toc: true
number-sections: true
link-external-newwindow: true
smooth-scroll: true
fig-responsive: true
echo: true
callout-appearance: simple
code-fold: true

filters:
     - nutshell
---

```{r, include = FALSE}
#knitr::opts_chunk$set(engine.opts = list(bash = "-l"))
```

# Introduction

This project was made possible with Quarto. [@aboutqu]

## Problem

The steps involved in reproducing data can be unclear.

## Purpose

To elaborate on the objective stated at the top of this document, the purpose is to supplement the DNA Zoo's report with a more easily accessible data analysis (DA) pipeline. To accomplish this, I seek to independently reproduce and supplement their article's table while supplying all data processing steps with documented code embedded in the report itself. Although there's nothing wrong with the data or article, it could be taken further. [@dnazoo], [@magicica]

## Stakeholders

This might be of interest to the original authors of the article. More generally, the spirit of this work could transfer to other domains of data intensive research and analytics.

## Source

All data used within this report was freely available from a public database hosted by DNA Zoo. [@dnazoo.s]

# Extract

This would be the data extraction phase of the DA pipeline.

## Create Project Directory

```{r}
#| label: src_directorize.py

reticulate::source_python("00_Extract/scripts/directorize.py")
```

```{python}
#| label: code_directorize.py
#| code-summary: Code for creating the project's analysis directory.
#| file: "00_Extract/scripts/directorize.py"
#| eval: false 

```

```{python}
#| label: exe_directorize.py
#| code-summary: Does not need to be evaluated during quarto render. Please run this locally for initializing the project directory structure. 

# Define the directory structure
structure = {
    "00_Extract/": ["data/", "scripts/"],
    "01_Transform/": ["data/", "scripts/"],
    "02_Load/": ["data/", "scripts/"],
    "03_Present/": ["data/", "scripts/"]
}

# Create the analysis folder structure in a preferred base directory
# "" = project's working directory
directorize("", structure)
```

## Download to Local Machine

```{r}
#| label: src_importer.py
reticulate::source_python(
    "00_Extract/scripts/importer.py")
```

```{python}
#| label: code_importer.py
#| code-summary: For importing files.
#| file: "00_Extract/scripts/importer.py"
#| eval: false 

```

```{python}
#| label: exe_importer.py

# Set the url
url = "https://dnazoo.s3.wasabisys.com/Magicicada_septendecula/magicicada_hifiasm.asm.bp.p_ctg_HiC.fasta.gz"

# Set the local file path
fpath = "00_Extract/data/magicicada.fasta.gz"

# Map the url to the file path
fileMap = {url: fpath}

importer(fileMap)
```

::: callout-note
## The specific link used to download all data from

`{r} reticulate::py$url`
:::

**Contigs** are crucial in accurately reconstructing the DNA sequence in a specific region. **Scaffolds** extend this by aligning contigs in a probable order, bridging the gaps with estimated sequences or placeholders.

# Transform

The data transformation phase of the pipeline.

## Decompress .GZ

```{r}
#| label: src_decompress.py

reticulate::source_python("01_Transform/scripts/decompress.py")
```

```{python}
#| label: code_decompress.py
#| code-summary: Decompressing from .gz to .fasta file format.
#| file: "01_Transform/scripts/decompress.py"
#| eval: false 

```

```{python}
#| label: exe_decompress.py

# Set the compressed fasta.gz file variable
gzFasta = "00_Extract/data/magicicada.fasta.gz"

# Set the decompressed fasta file variable
fasta = "01_Transform/data/magicicada.fasta"

decompress(gzFasta, fasta)
```

This chunk should be ran locally instead of with `quarto render`. If desired, when working with the source file, change the code-chunk language specifier from `{.bash}` back to `{bash}`. Not sure how else to go about accomplishing this within Quarto.

``` bash

# The uncompressed fasta file variable
fasta=01_Transform/data/magicicada.fasta

# The text file path variable generated by the script
summary_stats=01_Transform/data/summary_stats.txt

assembly_stats $fasta > $summary_stats
```

Transform the text file into a Python dataframe. I am opting to not to blanket change data-types as output format could vary by user preference.

```{r}
# Import  external python script to local library environment
reticulate::source_python("01_Transform/scripts/assemblyFramer.py")
```

```{python}
#| label: assemblyFramer_code_view
#| code-summary: For importing files.
#| file: "01_Transform/scripts/assemblyFramer.py"
#| eval: false 

```

```{python}
#| label: run_assemblyFramer

# Set the local text file path
statsPath = "01_Transform/data/summary_stats.txt"
# Run to yield an multi-indexed dataframe
stats_df = assemblyFramer(statsPath)
```

# Load

This is the data loading phase. Following completion of this stage, querying the data should be more intuitive than before.

```{r}
#| include: true

reticulate::source_python("02_Load/scripts/strint.py")
```

```{python}
#| label: strint_view
#| code-summary: For adjusting output formatting of the stats.
#| file: "02_Load/scripts/strint.py"
#| eval: false 

```

```{python}
#| label: tableVariables
#| code-summary: Set all of the table values.

ctig_len = strint(stats_df, "Contigs", "total_bps")
ctig_count = strint(stats_df, "Contigs", "sequence_count")
ctig_n50 = strint(stats_df, "Contigs", "N50")
ctig_max = strint(stats_df, "Contigs", "longest")

sfld_len = strint(stats_df, "Scaffolds", "total_bps")
sfld_count = strint(stats_df, "Scaffolds", "sequence_count")
sfld_n50 = strint(stats_df, "Scaffolds", "N50")
sfld_max = strint(stats_df, "Scaffolds", "longest")

```

::: {.callout-tip appearance="simple"}
## Python query syntax made easier

```{python}
#| eval: false
#| code-fold: false
#| echo: true

ctig_len = strint(dataframe, category, label)

```
:::

```{r}
#| label: load_reticulate
#| code-summary: To make the variable calls simpler in the table below. See source code to better understand.

library(reticulate)
```

# Present

## The Pandas Table

This is a slightly formatted view of the Pandas table designed to be more easily queried to return the desired statistic.

```{r}
#| label: src_style_df.py

reticulate::source_python("03_Present/scripts/style_df.py")
```

```{python}

styldf = style_df(stats_df, cap = "Summary")

styldf
```

## DNA Zoo's Table, Reproduced

|                        |                       |                     |                         |
|------------------|------------------|------------------|------------------|
| **Contig length (bp)** | **Number of contigs** | **Contig N50 (bp)** | **Longest contig (bp)** |
| `{r} py$ctig_len`      | `{r} py$ctig_count`   | `{r} py$ctig_n50`   | `{r} py$ctig_max`       |

|                          |                         |                       |                           |
|------------------|------------------|------------------|------------------|
| **Scaffold length (bp)** | **Number of scaffolds** | **Scaffold N50 (bp)** | **Longest scaffold (bp)** |
| `{r} py$sfld_len`        | `{r} py$sfld_count`     | `{r} py$sfld_n50`     | `{r} py$ sfld_max`        |

**The** **contig N50** is a statistical measure that represents the length of the longest contig (contiguous assembled sequence) for which the sum of the lengths of all contigs of equal or greater length is at least 50% of the total genome length. In other words, it is the length of the contig at which 50% of the genome assembly is contained in contigs of that length or longer. A higher contig N50 value indicates that the assembly contains fewer and longer contigs, which is generally desirable as it suggests a more contiguous and complete assembly. A lower contig N50 value indicates that the assembly is more fragmented, with shorter contigs.

**The** **scaffold N50** is similar to the contig N50, but it considers scaffolds instead of contigs. Scaffolds are ordered and oriented contigs with gaps (represented by N's) in between them. Likewise, the scaffold N50 is the length of the longest scaffold for which the sum of the lengths of all scaffolds of equal or greater length is at least 50% of the total genome length. A higher scaffold N50 value suggests that the assembly is more contiguous, with fewer and longer scaffolds. This indicates that more contigs have been correctly ordered and oriented into scaffolds, bridging the gaps between them.

**Both contig N50 and scaffold N50** are widely used to evaluate the quality and completeness of genome assemblies, especially when comparing different assembly strategies or tools.

[De novo assembly of the Aedes aegypti genome using Hi-C yields chromosome-length scaffolds \| Science](https://www.science.org/doi/10.1126/science.aal3327)

```{mermaid}


```
