---
title: "Cicada Data"
subtitle: "Data analysis reproduction concerning the cicada's genome."
author: "Eric Mossotti"
date: today
date-modified: last-modified

bibliography: references.bib
repo: https://github.com/ericMossotti/genomics
source: genomics.qmd
abstract-title: "Objective"
abstract: "To reproduce the summary table on the cicada species summary statistics table."
description-meta: "Reproducible genomics analysis."
license: CC BY-SA
funding: "The author(s) received no specific funding for this work."

csl: csl/apa.csl
citation-location: margin
citations-hover: true
link-citations: true

toc-expand: true
toc: true
number-sections: true
link-external-newwindow: true
smooth-scroll: true
fig-responsive: true
echo: true
callout-appearance: simple

code-fold: true

engine: knitr
---

```{r, include = FALSE}
#knitr::opts_chunk$set(engine.opts = list(bash = "-l"))
```

# Introduction

## Problem

Lack of documentation in bioinformatics research reporting. The steps involved to reproduce genomics data can be unclear.

## Purpose

To trail blaze a new trend in research reporting with respect to reproducibility. To address the well documented and ongoing reproducibility crisis, I seek to independently reproduce and supplement, in this case, bioinformatics research. This particular report aims to verify that a table related to a species of cicada is correct by programmatically reproducing it with publicly available bioinformatics tools.

## Stakeholders

I consider this work of particular interest to bioinformatics researchers. More generally, the spirit of this work could also transfer to other domains of data intensive research and analytics.

## Source

[@magicica]

# Extract

```{r}
reticulate::source_python(
    "00_Extract/scripts/importer.py")
```

```{python}
#| label: importScript
#| code-summary: For importing files.
#| file: "00_Extract/scripts/importer.py"
#| eval: false 

```

```{r}
reticulate::source_python("directorize.py")
```

```{python}
#| label: directorating
#| eval: false
#| code-summary: Does not need to be evaluated during quarto render. Please run this locally for initializing project folder structure. 

# Define the directory structure
structure = {
    "00_Extract/": ["data/", "scripts/"],
    "01_Transform/": ["data/", "scripts/"],
    "02_Load/": ["data/", "scripts/"]
}

# Create the analysis folder structure in a preferred base directory
# "" = project's working directory
directorize("", structure)
```

```{python}
#| label: importChunk

# Set the url
url = "https://dnazoo.s3.wasabisys.com/Magicicada_septendecula/magicicada_hifiasm.asm.bp.p_ctg_HiC.fasta.gz"

# Set the local file path
fpath = "00_Extract/data/magicicada.fasta.gz"

# Map the url to the file path
fileMap = {url: fpath}

importer(fileMap)
```

**Contigs** are crucial in accurately reconstructing the DNA sequence in a specific region. **Scaffolds** extend this by aligning contigs in a probable order, bridging the gaps with estimated sequences or placeholders.

# Transform

## Decompress

```{r}
reticulate::source_python("01_Transform/scripts/decompress.py")
```

```{python}

# Set the compressed fasta.gz file variable
gzFasta = "00_Extract/data/magicicada.fasta.gz"

# Set the decompressed fasta file variable
fasta = "01_Transform/data/magicicada.fasta"

decompress(gzFasta, fasta)
```

This chunk should be ran locally instead of with `quarto render`. When working with the source file, change the code-chunk language specifier from `{.bash}` to `{bash}`. Not sure how else to go about accomplishing this.

``` bash

# The uncompressed fasta file variable
fasta=01_Transform/data/magicicada.fasta

# The text file path variable generated by the script
summary_stats=01_Transform/data/summary_stats.txt

assembly_stats $fasta > $summary_stats
```

Transform the text file into a Python dataframe. I am opting to not to blanket change data-types as output format could vary by user preference. Converting everything to floats has unintended consequences as does converting everything to integers. I don't need to perform any further calculations with this data, so strings seem fine.

```{r}
##| include: false
reticulate::source_python("01_Transform/scripts/assemblyFramer.py")

```

```{python}
#| label: assemblyFramer_code_view
#| code-summary: For importing files.
#| file: "01_Transform/scripts/assemblyFramer.py"
#| eval: false 

```

```{python}
#| label: run_assemblyFramer

statsPath = "01_Transform/data/summary_stats.txt"

stats_df = assemblyFramer(statsPath)

```

# Load

In this stage, the dataframe can be easily queried and the specific stats quickly loaded into the table.

```{r}
#| include: true
reticulate::source_python("02_Load/scripts/strint.py")

```

```{python}
#| label: strint_view
#| code-summary: For adjusting output formatting of the stats.
#| file: "02_Load/scripts/strint.py"
#| eval: false 

```

```{python}
#| label: tableVariables
#| code-summary: Set all of the table values.

ctig_len = strint(stats_df, "Contigs", "total_bps")
ctig_count = strint(stats_df, "Contigs", "sequence_count")
ctig_n50 = strint(stats_df, "Contigs", "N50")
ctig_max = strint(stats_df, "Contigs", "longest")

sfld_len = strint(stats_df, "Scaffolds", "total_bps")
sfld_count = strint(stats_df, "Scaffolds", "sequence_count")
sfld_n50 = strint(stats_df, "Scaffolds", "N50")
sfld_max = strint(stats_df, "Scaffolds", "longest")

```

```{r}
#| label: load_reticulate
#| code-summary: To make the variable calls simpler in the table below. See source code to better understand.

library(reticulate)
```

## Tables

|                        |                       |                     |                         |
|------------------|------------------|------------------|------------------|
| **Contig length (bp)** | **Number of contigs** | **Contig N50 (bp)** | **Longest contig (bp)** |
| `{r} py$ctig_len`      | `{r} py$ctig_count`   | `{r} py$ctig_n50`   | `{r} py$ctig_max`       |

|                          |                         |                       |                           |
|------------------|------------------|------------------|------------------|
| **Scaffold length (bp)** | **Number of scaffolds** | **Scaffold N50 (bp)** | **Longest scaffold (bp)** |
| `{r} py$sfld_len`        | `{r} py$sfld_count`     | `{r} py$sfld_n50`     | `{r} py$ sfld_max`        |

**The** **contig N50** is a statistical measure that represents the length of the longest contig (contiguous assembled sequence) for which the sum of the lengths of all contigs of equal or greater length is at least 50% of the total genome length. In other words, it is the length of the contig at which 50% of the genome assembly is contained in contigs of that length or longer. A higher contig N50 value indicates that the assembly contains fewer and longer contigs, which is generally desirable as it suggests a more contiguous and complete assembly. A lower contig N50 value indicates that the assembly is more fragmented, with shorter contigs.

**The** **scaffold N50** is similar to the contig N50, but it considers scaffolds instead of contigs. Scaffolds are ordered and oriented contigs with gaps (represented by N's) in between them. Likewise, the scaffold N50 is the length of the longest scaffold for which the sum of the lengths of all scaffolds of equal or greater length is at least 50% of the total genome length. A higher scaffold N50 value suggests that the assembly is more contiguous, with fewer and longer scaffolds. This indicates that more contigs have been correctly ordered and oriented into scaffolds, bridging the gaps between them.

**Both contig N50 and scaffold N50** are widely used to evaluate the quality and completeness of genome assemblies, especially when comparing different assembly strategies or tools.

[De novo assembly of the Aedes aegypti genome using Hi-C yields chromosome-length scaffolds \| Science](https://www.science.org/doi/10.1126/science.aal3327)

```{mermaid}

```
