{
  "hash": "987613145e6565e425c3e7b42ac57e0d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Cicada Data\"\nsubtitle: \"Data analysis reproduction concerning the cicada's genome.\"\nauthor: \"Eric Mossotti\"\ndate: today\ndate-modified: last-modified\n\nbibliography: references.bib\nrepo: https://github.com/ericMossotti/genomics\nsource: genomics.qmd\nabstract-title: \"Objective\"\nabstract: \"To reproduce the summary table on the cicada species summary statistics table.\"\ndescription-meta: \"Reproducible genomics analysis.\"\nlicense: CC BY-SA\nfunding: \"The author(s) received no specific funding for this work.\"\n\ncsl: csl/apa.csl\ncitation-location: margin\ncitations-hover: true\nlink-citations: true\n\ntoc-expand: true\ntoc: true\nnumber-sections: true\nlink-external-newwindow: true\nsmooth-scroll: true\nfig-responsive: true\necho: true\ncallout-appearance: simple\n\ncode-fold: true\n---\n\n\n\n\n\n# Introduction\n\n## Problem\n\nLack of documentation in bioinformatics research reporting. The steps involved to reproduce genomics data can be unclear.\n\n## Purpose\n\nTo trail blaze a new trend in research with regards to reproducibility. To address the well documented and ongoing reproducibility crisis, I seek to reproduce and supplement, in this case, bioinformatics research, independently.\n\n## Stakeholders\n\nI consider this work of particular interest to bioinformatics researchers. More generally, the spirit of this work could translate to other domains of data intensive research and analytics.\n\n## Source\n\nThis particular report aims to verify a table related to a species of cicada is correct by programmatically reproducing it with publicly available bioinformatics tools. [@magicica]\n\n# Import\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreticulate::source_python(\"Scripts/00_Import/Python/importer/importer.py\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code  code-summary=\"For importing files.\"}\n''' importer.py '''\nimport os\nimport wget\n\ndef importer (directory, fileMap):\n    \n    # Check for directory, then skip, or create dir and import files\n    if not os.path.exists(directory):\n        \n        os.makedirs(directory)\n        print(f\"Directory {directory} created successfully.\")\n        \n    # Otherwise, notify if exists\n    else:\n        print(f\"Directory {directory} already exists.\")\n                    \n    # Download from URL to path and notify when complete\n    for url, file_path in fileMap.items():\n        \n        # Check if file exists before downloading\n        if not os.path.exists(file_path):\n            \n            wget.download(url, file_path)\n            print(f\"{file_path} written\")\n            \n        else:\n            print(f\"{file_path} already exists.\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\nimport sys\nimport wget\n\n# Define the directory name\ndirectory = \"data\"\n\n# Set the url\nurl = \"https://dnazoo.s3.wasabisys.com/Magicicada_septendecula/magicicada_hifiasm.asm.bp.p_ctg_HiC.fasta.gz\"\n\n# Set the local file path\nfpath = \"data/magicicada.fasta.gz\"\n\n# Map the url to the file path\nfileMap = {url: fpath}\n\nimporter(directory, fileMap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDirectory data already exists.\ndata/magicicada.fasta.gz already exists.\n```\n\n\n:::\n:::\n\n\n\nContigs are crucial in accurately reconstructing the DNA sequence in a specific region. Scaffolds extend this by aligning contigs in a probable order, bridging the gaps with estimated sequences or placeholders.\n\n# Process\n\n## Decompress\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\n# A script to decompress the fasta file in order to run assembly_stats python function on it later.\n\n# In a quarto IDE project, run by removing '.' from '{.bash}' \n# Bash chunks fail to run with this setup, so still figuring that out\n# Run chunk in IDE, then add '.' to '{bash}' before render\n\n# The decompressed fasta file variable\nfasta=\"data/magicicada.fasta\"\n# The compressed fasta.gz file variable\ngzFasta=\"data/magicicada.fasta.gz\"\n\n# Check if gzFasta is already decompressed and written to the location\nif [ ! -f $fasta ]; then\n    # File doesn't exist, then decompress\n    gunzip -c \"$gzFasta\" > \"$fasta\"\n    echo \"$fasta has been decompressed and written.\" \nelse\n    echo \"The file $fasta already exists. Skipping unzip.\"\nfi\n\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe file  already exists. Skipping unzip.\n```\n\n\n:::\n:::\n\n\n\n# EDA\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\nimport subprocess\n\n# The uncompressed fasta file variable\nfasta = \"data/magicicada.fasta\"\n# The text file path variable generated by the script\nsummary_stats = \"data/01_EDA/summaryStats.txt\"\n# The file path to the bash script\nscript_file = \"Scripts/01_EDA/Bash/assembly_stats.sh\"\n\n# Check if the summaryStats file exists\nif not os.path.isfile(summary_stats):\n    # File doesn't exist, execute the Bash command\n    try:\n        # Run the bash script and capture its output\n        output = subprocess.check_output([\"bash\", script_file, fasta],\n        universal_newlines = True)\n        \n        # Write the output to the summary_stats file\n        with open(summary_stats, 'w') as f:\n            f.write(output)\n        \n        # Print the contents of the file\n        print(output)\n        \n    except subprocess.CalledProcessError as e:\n        print(f\"An error occurred while running the script: {e}\")\nelse:\n    print(f\"The file {summary_stats} already exists. Skipping execution.\\n\"\n    )\n    with open(summary_stats, 'r') as f:\n        contents = f.read()\n        print(\"File contents:\\n\", contents)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe file data/01_EDA/summaryStats.txt already exists. Skipping execution.\n\nFile contents:\n \n  \"Contig Stats\": {\n    \"L10\": 41,\n    \"L20\": 99,\n    \"L30\": 174,\n    \"L40\": 267,\n    \"L50\": 385,\n    \"N10\": 12643769,\n    \"N20\": 9681846,\n    \"N30\": 7895799,\n    \"N40\": 6288966,\n    \"N50\": 4902968,\n    \"gc_content\": 35.248103813419206,\n    \"longest\": 43529772,\n    \"mean\": 1552486.9914285715,\n    \"median\": 331935.0,\n    \"sequence_count\": 4200,\n    \"shortest\": 1000,\n    \"total_bps\": 6520445364\n  },\n  \"Scaffold Stats\": {\n    \"L10\": 0,\n    \"L20\": 0,\n    \"L30\": 1,\n    \"L40\": 2,\n    \"L50\": 3,\n    \"N10\": 1438277616,\n    \"N20\": 1438277616,\n    \"N30\": 915491830,\n    \"N40\": 607508155,\n    \"N50\": 518932092,\n    \"gc_content\": 35.248103813419206,\n    \"longest\": 1438277616,\n    \"mean\": 3212576.533990148,\n    \"median\": 62362.5,\n    \"sequence_count\": 2030,\n    \"shortest\": 1000,\n    \"total_bps\": 6521530364\n  }\n```\n\n\n:::\n:::\n\n\n\n## Tables\n\n|                        |                       |                     |                         |\n|------------------------|-----------------------|---------------------|-------------------------|\n| **Contig length (bp)** | **Number of contigs** | **Contig N50 (bp)** | **Longest contig (bp)** |\n|                        |                       |                     |                         |\n\n|                          |                         |                       |                           |\n|--------------------------|-------------------------|-----------------------|---------------------------|\n| **Scaffold length (bp)** | **Number of scaffolds** | **Scaffold N50 (bp)** | **Longest scaffold (bp)** |\n|                          |                         |                       |                           |\n\n**The** **contig N50** is a statistical measure that represents the length of the longest contig (contiguous assembled sequence) for which the sum of the lengths of all contigs of equal or greater length is at least 50% of the total genome length. In other words, it is the length of the contig at which 50% of the genome assembly is contained in contigs of that length or longer. A higher contig N50 value indicates that the assembly contains fewer and longer contigs, which is generally desirable as it suggests a more contiguous and complete assembly. A lower contig N50 value indicates that the assembly is more fragmented, with shorter contigs.\n\n**The** **scaffold N50** is similar to the contig N50, but it considers scaffolds instead of contigs. Scaffolds are ordered and oriented contigs with gaps (represented by N's) in between them. Likewise, the scaffold N50 is the length of the longest scaffold for which the sum of the lengths of all scaffolds of equal or greater length is at least 50% of the total genome length. A higher scaffold N50 value suggests that the assembly is more contiguous, with fewer and longer scaffolds. This indicates that more contigs have been correctly ordered and oriented into scaffolds, bridging the gaps between them.\n\n**Both contig N50 and scaffold N50** are widely used to evaluate the quality and completeness of genome assemblies, especially when comparing different assembly strategies or tools.\n\n[De novo assembly of the Aedes aegypti genome using Hi-C yields chromosome-length scaffolds \\| Science](https://www.science.org/doi/10.1126/science.aal3327)\n\n\n\n```{mermaid}\n\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}