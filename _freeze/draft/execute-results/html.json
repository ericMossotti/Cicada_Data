{
  "hash": "6af1ca2be53bc0dbff58ddbac03da346",
  "result": {
    "engine": "jupyter",
    "markdown": ":::{#899e7b9a .cell .markdown}\n**Contigs** are crucial in accurately reconstructing the DNA sequence in a specific region. **Scaffolds** extend this by aligning contigs in a probable order, bridging the gaps with estimated sequences or placeholders.\n\n**The** **contig N50** is a statistical measure that represents the length of the longest contig (contiguous assembled sequence) for which the sum of the lengths of all contigs of equal or greater length is at least 50% of the total genome length. In other words, it is the length of the contig at which 50% of the genome assembly is contained in contigs of that length or longer. A higher contig N50 value indicates that the assembly contains fewer and longer contigs, which is generally desirable as it suggests a more contiguous and complete assembly. A lower contig N50 value indicates that the assembly is more fragmented, with shorter contigs.\n\n**The** **scaffold N50** is similar to the contig N50, but it considers scaffolds instead of contigs. Scaffolds are ordered and oriented contigs with gaps (represented by N's) in between them. Likewise, the scaffold N50 is the length of the longest scaffold for which the sum of the lengths of all scaffolds of equal or greater length is at least 50% of the total genome length. A higher scaffold N50 value suggests that the assembly is more contiguous, with fewer and longer scaffolds. This indicates that more contigs have been correctly ordered and oriented into scaffolds, bridging the gaps between them.\n\n**Both contig N50 and scaffold N50** are widely used to evaluate the quality and completeness of genome assemblies, especially when comparing different assembly strategies or tools.\n:::\n\n::: {#a8c0f521 .cell execution_count=1}\n``` {}\n#| eval: false\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\n\n# Create a sample multi-indexed DataFrame\nindex = pd.MultiIndex.from_product(\n    [['A', 'B', 'C'], ['X', 'Y', 'Z']])\ndf = pd.DataFrame(\n    np.random.randn(9, 3), index=index, columns=['Col1', 'Col2', 'Col3'])\n\n# Create a seaborn color palette\npalette = sns.color_palette(\"husl\", n_colors=len(df.index.levels[1]))\n\npalette\n\n# Function to apply colors to index levels\ndef color_index(row):\n    color = palette[row.name[0]]  \n    # Get color based on first level of index\n    return [f'background-color: rgba({int(color[0]*255)}, {int(color[1]*255)}, {int(color[2]*255)}, 0.5)'] * len(row)\n\n# Apply the styling\nstyled_df = df.style.apply(color_index, axis=1)\n\n\n\n# Display the styled DataFrame\nstyled_df\n\nstats_df.Contigs[]\n```\n:::\n\n\n::: {#best-output-so-far .cell execution_count=2}\n``` {}\n#| label: best output so far\n#| eval: false\n# This gives a color scheme that visually distinguishes the first level of the index while grouping rows by their second-level index across all columns. The column headers will also have colors from the same palette as the second-level index. You can adjust the color palettes and alpha values to fine-tune the appearance as needed.\n\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\n\n# Create color palettes for first level index and second level index + columns\nn_colors1 = len(df.index.levels[0])\nn_colors2 = len(df.index.levels[1]) + len(df.columns)\npalette1 = sns.color_palette(\"husl\", n_colors=n_colors1)\npalette2 = sns.color_palette(\"Set2\", n_colors=n_colors2)\n\n# Map index levels and column names to colors with dictionaries\ncolor_dict1 = dict(zip(df.index.levels[0], palette1))\ncolor_dict2 = dict(zip(list(df.index.levels[1]) + list(df.columns), palette2))\n\ndef color_to_rgba(color, alpha = 0.5):\n    return f'background-color: rgba({\", \".join(f\"{int(c*255)}\" for c in color)}, {alpha})'\n\ndef color_index(index):\n    # For full multi-index, use color from first level\n    if isinstance(index, tuple):\n        # For full multi-index, use color from first level\n        return color_to_rgba(color_dict1[index[0]])\n    # For single-level indices, use appropriate color dictionaries\n    elif index in color_dict2:\n        return color_to_rgba(color_dict2[index])\n    else:\n        return ''\n\ndef color_values(s):\n    # List comprehension \n    return [color_to_rgba(color_dict2[idx[1]]) for idx in s.index]\n\n# Apply the styling\nstyled_df = df.style.map_index(color_index, axis=0)\nstyled_df = styled_df.apply(color_values, axis=0)\n\n# Display the styled DataFrame\nstyled_df\n```\n:::\n\n\n",
    "supporting": [
      "draft_files"
    ],
    "filters": [],
    "includes": {}
  }
}